<!DOCTYPE html><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="alternate" type="application/atom+xml" href="../feed.atom">
<link rel="shortcut icon" href="../graphics/logo.ico">
<link rel="preload" href="../fonts/genoa_italic_filtered.woff" as="font" type="font/woff">
<title>Transitive Closure in SQL</title>
<meta name="description" content="Using recursive common table expressions in SQL to find the transitive closure.">
<meta name="keywords" content="sql, relational algebra, python">
<meta name="generator" content="Org mode">
<link rel="stylesheet" type="text/css" href="../css/main.css">
<link rel="stylesheet" type="text/css" href="../css/exposition.css">
<link rel="stylesheet" type="text/css" href="../css/blog.css">
<link rel="stylesheet" type="text/css" href="../css/sql-transitive-closure.css">
</head>
<body>
<header id="masthead"><input id="expand-blog-menu" type="checkbox" tabindex="2"><div id="dwhoman-logo" class="nav"><a href="../index.html" tabindex="1"><span>D</span><span>W</span><span>H</span></a></div>
<label id="expand-blog-menu-inactive" class="nav menu menu-btn" for="expand-blog-menu"><span>Blog</span><img src="../graphics/noun_1322581_cc.svg" alt=""></label><label id="expand-blog-menu-active" class="nav blog-menu menu-btn" for="expand-blog-menu"><span>Main Menu</span><img src="../graphics/noun_1355740_cc.svg" alt=""></label><div id="blog-chronologic" class="nav blog-menu menu-btn"><a href="../chronological.html" tabindex="3"><span>Chronological</span><img src="../graphics/noun_333757_cc.svg" alt=""></a></div>
<div id="blog-recent" class="nav blog-menu menu-btn"><a href="../recent-updates.html" tabindex="4"><span>Updated</span><img src="../graphics/noun_1572678_cc.svg" alt=""></a></div>
<div id="blog-categories" class="nav blog-menu menu-btn"><a href="../categories.xhtml" tabindex="5"><span>Categories</span><img src="../graphics/noun_1332809_cc.svg" alt=""></a></div>
<div id="blog-threads" class="nav blog-menu menu-btn"><a href="../threads.html" tabindex="6"><span>Threads</span><img src="../graphics/noun_844785_cc.svg" alt=""></a></div>
<div id="blog-feed" class="nav blog-menu menu-btn"><a href="../feed.atom" tabindex="7"><span>Feed</span><img src="../graphics/noun_19895_cc.svg" alt=""></a></div>
<div id="about-page" class="nav menu menu-btn"><a href="../about.html" tabindex="8"><span>About</span><img src="../graphics/info.svg" alt=""></a></div>
<div id="resume-page" class="nav menu menu-btn"><a href="../resume.html" tabindex="9"><span>R<span class="acute-e">e</span>sum<span class="acute-e">e</span></span><img src="../graphics/noun_591006_cc.svg" alt=""></a></div>
<div id="project-page" class="nav menu menu-btn"><a href="https://github.com/dwhoman" tabindex="10"><span>Projects</span><img src="../graphics/Git-logo.svg" alt=""></a></div>
<div id="following-page" class="menu nav menu-btn"><a href="../blog/following.html" tabindex="11"><span>Following</span><img src="../graphics/noun_541507_cc.svg" alt=""></a></div>
<div id="blog-feed-comp" class="filler menu"></div>
<div id="nav-filler" class="filler"></div>
<div id="to-top" class="nav menu-btn"><a href="#" tabindex="12"><span>Back to Top</span><img src="../graphics/to_top.svg" alt=""></a></div></header><aside id="related-posts"><nav id="blog-threads-local"><h2>Thread</h2>
<dl>
<dt>Prev:</dt>
<dd class="cloud"><a href="sql-relational-algebra.html">SQL Relational Algebra</a></dd>
<dt>Next:</dt>
<dd class="cloud"><a href="sql-number-length-dag.html">Number Length Directed Graph</a></dd>
</dl></nav><nav id="blog-published-local"><h2>Published</h2>
<dl>
<dt>Prev:</dt>
<dd class="cloud"><a href="sql-relational-algebra.html">SQL Relational Algebra</a></dd>
<dt>Next:</dt>
<dd class="cloud"><a href="sql-number-length-dag.html">Number Length Directed Graph</a></dd>
</dl></nav><nav id="blog-updated-local"><h2>Updated</h2>
<dl>
<dt>Prev:</dt>
<dd class="cloud"><a href="rolling-my-own-static-site-generator.html">Rolling My Own Static Site Generator</a></dd>
<dt>Next:</dt>
<dd class="cloud"><a href="keyboard-layouts.html">Keyboard Layouts</a></dd>
</dl></nav><nav id="tag-list"><h2>Tags</h2>
<ul>
<li><a href="../categories.xhtml#python">python</a></li>
<li><a href="../categories.xhtml#relational_algebra">relational algebra</a></li>
<li><a href="../categories.xhtml#sql">sql</a></li>
</ul></nav></aside><aside id="generation-dates"><ul>
<li id="publication-date">Published: <time datetime="2016-09-11T00:00:00">September 11 2016</time>
</li>
<li id="update-date">Updated: <time datetime="2018-04-07T20:07:00">April 07 2018</time>
</li>
<li id="markup-source"><a href="sql-transitive-closure.org" type="text/plain" download="sql-transitive-closure.org">Page Markup Source</a></li>
</ul></aside><main id="content">
<h1 class="title">Transitive Closure in SQL</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li>
<a href="#org3434960">1. Transitive Closure in SQL</a>
<ul>
<li>
<a href="#org5a21f7d">1.1. Recursive Queries and SQLite's Examples</a>
<ul>
<li><a href="#orgff3b734">1.1.1. Breadth First Search</a></li>
<li><a href="#org62155e8">1.1.2. Depth First Search</a></li>
</ul>
</li>
<li><a href="#org99139fa">1.2. Memoization Example</a></li>
<li>
<a href="#org6725559">1.3. Transitive Closure Example</a>
<ul>
<li><a href="#orge7328d7">1.3.1. Using Relational Algebra and Python</a></li>
<li><a href="#org991be95">1.3.2. Using SQLite and Recursive Common Table Expressions</a></li>
<li>
<a href="#org26850e3">1.3.3. Cyclic Graphs</a>
<ul>
<li><a href="#org50fb68e">1.3.3.1. Another Example</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<article id="outline-container-org3434960" class="outline-2">
<h2 id="org3434960">
<span class="section-number-2">1</span> Transitive Closure in SQL</h2>
<div class="outline-text-2" id="text-1">
<p>
<a href="https://en.wikipedia.org/wiki/Transitive_closure">Transitive closure</a> is an operation on relation tables that is not expressible
in relational algebra. Transitive closure is an operation on directed graphs
where the output is a graph with direct connections between nodes only when
there is a path between those nodes in the input graph. The transitive
closure is possible to compute in SQL by using recursive common table
expressions (CTEs). SQLite has a good <a href="https://sqlite.org/lang_with.html">article</a> on recursive CTEs, even using it
for more general purpose computing.
</p>

<p>
The paper, <a href="https://www.academia.edu/14343057/Universality_of_data_retrieval_languages">Universality of Data Retrieval Languages</a>, by Aho and Ullman, shows
why some <a href="https://en.wikipedia.org/wiki/Fixed-point_combinator">least fixed point operators</a>, such as the transitive closure, are not
possible with relational algebra. A fixed point operator is a operator that
returns its input, which is what the transitive closure eventually
does. Feeding a transitive closure output back into the function will produce
the same output.  I suppose it is called a "least" fixed point operator
because it returns the smallest possible transitively closed graph containing
the input graph.
</p>
</div>

<div id="outline-container-org5a21f7d" class="outline-3">
<h3 id="org5a21f7d">
<span class="section-number-3">1.1</span> Recursive Queries and SQLite's Examples</h3>
<div class="outline-text-3" id="text-1-1">
<p>
Here I step through the "Controlling Depth-First Versus Breadth-First Search
Of a Tree Using ORDER BY" examples given in the SQLite online documentation.
</p>
</div>

<div id="outline-container-orgff3b734" class="outline-4">
<h4 id="orgff3b734">
<span class="section-number-4">1.1.1</span> Breadth First Search</h4>
<div class="outline-text-4" id="text-1-1-1">
<p>
A recursive query is one with the form:
</p>
<div class="org-src-container">
<pre class="src src-sqlite"><span class="org-keyword">WITH</span> <span class="org-keyword">RECURSIVE</span>
  under_alice(<span class="org-keyword">name</span>,<span class="org-keyword">level</span>) <span class="org-keyword">AS</span> (
    <span class="org-keyword">VALUES</span>(<span class="org-string">'Alice'</span>,0)
    <span class="org-keyword">UNION</span> <span class="org-keyword">ALL</span>
    <span class="org-keyword">SELECT</span> org.<span class="org-keyword">name</span>, under_alice.<span class="org-keyword">level</span>+1
      <span class="org-keyword">FROM</span> org <span class="org-keyword">JOIN</span> under_alice <span class="org-keyword">ON</span> org.boss=under_alice.<span class="org-keyword">name</span>
     <span class="org-keyword">ORDER</span> <span class="org-keyword">BY</span> 2 <span class="org-keyword">ASC</span>
  )
<span class="org-keyword">SELECT</span> substr(<span class="org-string">'..........'</span>,1,<span class="org-keyword">level</span>*3) || <span class="org-keyword">name</span> <span class="org-keyword">FROM</span> under_alice;
</pre>
</div>

<p>
<code>under_alice</code> looks like a function that takes parameters, but it is
not. What look to be parameters, are actually the column names of the return
value, so <code>org.name, under_alice.level+1</code> becomes <code>under_alice.name,
    under_alice.level</code>. The last SELECT statement just formats the result from
<code>under_alice</code>. The <code>under_alice</code> query makes reference to the <code>org</code> table:
</p>

<table>


<colgroup>
<col class="org-left">

<col class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">name</th>
<th scope="col" class="org-left">boss</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Alice</td>
<td class="org-left">NULL</td>
</tr>

<tr>
<td class="org-left">Bob</td>
<td class="org-left">Alice</td>
</tr>

<tr>
<td class="org-left">Cindy</td>
<td class="org-left">Alice</td>
</tr>

<tr>
<td class="org-left">Dave</td>
<td class="org-left">Bob</td>
</tr>

<tr>
<td class="org-left">Emma</td>
<td class="org-left">Bob</td>
</tr>

<tr>
<td class="org-left">Fred</td>
<td class="org-left">Cindy</td>
</tr>

<tr>
<td class="org-left">Gail</td>
<td class="org-left">Cindy</td>
</tr>
</tbody>
</table>

<p>
The SQLite article explains how recursive queries proceed.  Stepping through
that process with the <code>under_alice</code> query: When recursing, two tables are
created, the <em>recursive table</em> and the <em>queue</em>. So stepping through the code:
Initially <code>VALUES('Alice',0)</code> is stored in the <em>queue</em>, and the <em>recursive
table</em> is empty. The part after the <code>UNION ALL</code> is the recursion loop.  The
statement, <code>VALUES('Alice',0)</code>, does not get re-evaluated. In the first
iteration, the top value from the <em>queue</em> is moved to the <em>recursive table</em>
and it also becomes the value that <code>under_alice</code> refers to in the
<code>SELECT...FROM...</code> statement.  The <code>org</code> table gets joined with <code>('Alice',0)
    ON org.boss = 'Alice'</code>, and the table returned by the <code>SELECT...FROM...</code>
statement gets stored at the bottom of the queue, resulting in the tables
shown in step 1.  The algorithm repeats, step 2, Bob is pulled from the
<em>queue</em> and put into the <em>recursive table</em>, and the Bob record, <code>('Bob',1)</code>,
gets joined with the org table.  The result is then stored in the <em>queue</em>.
This repeats until the <em>queue</em> is empty; which is only possible if the <code>JOIN</code>
returns an empty table, which is does for Fred, Gail, Cindy, and Dave.
Otherwise the query would loop infinitely.  This query performs a breadth
first search.
</p>

<ul class="org-ul">
<li>
<p>
Step 0
</p>
<table>
<caption class="t-above">
<span class="table-number">Table 1:</span> Queue</caption>

<colgroup>
<col class="org-left">

<col class="org-right">
</colgroup>
<tbody>
<tr>
<td class="org-left">Alice</td>
<td class="org-right">0</td>
</tr>
</tbody>
</table>

<p>
The recursive table is empty.
</p>
</li>

<li>
<p>
Step 1
</p>
<table>
<caption class="t-above">
<span class="table-number">Table 2:</span> Recursive Table</caption>

<colgroup>
<col class="org-left">

<col class="org-right">
</colgroup>
<tbody>
<tr>
<td class="org-left">Alice</td>
<td class="org-right">0</td>
</tr>
</tbody>
</table>

<table>
<caption class="t-above">
<span class="table-number">Table 3:</span> Queue</caption>

<colgroup>
<col class="org-left">

<col class="org-right">
</colgroup>
<tbody>
<tr>
<td class="org-left">Bob</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left">Cindy</td>
<td class="org-right">1</td>
</tr>
</tbody>
</table>
</li>

<li>
<p>
Step 2
</p>
<table>
<caption class="t-above">
<span class="table-number">Table 4:</span> Recursive Table</caption>

<colgroup>
<col class="org-left">

<col class="org-right">
</colgroup>
<tbody>
<tr>
<td class="org-left">Alice</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-left">Bob</td>
<td class="org-right">1</td>
</tr>
</tbody>
</table>

<table>
<caption class="t-above">
<span class="table-number">Table 5:</span> Queue</caption>

<colgroup>
<col class="org-left">

<col class="org-right">
</colgroup>
<tbody>
<tr>
<td class="org-left">Cindy</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left">Dave</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-left">Emma</td>
<td class="org-right">2</td>
</tr>
</tbody>
</table>
</li>

<li>
<p>
Step 3
</p>
<table>
<caption class="t-above">
<span class="table-number">Table 6:</span> Recursive Table</caption>

<colgroup>
<col class="org-left">

<col class="org-right">
</colgroup>
<tbody>
<tr>
<td class="org-left">Alice</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-left">Bob</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left">Cindy</td>
<td class="org-right">1</td>
</tr>
</tbody>
</table>

<table>
<caption class="t-above">
<span class="table-number">Table 7:</span> Queue</caption>

<colgroup>
<col class="org-left">

<col class="org-right">
</colgroup>
<tbody>
<tr>
<td class="org-left">Dave</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-left">Emma</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-left">Fred</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-left">Gail</td>
<td class="org-right">2</td>
</tr>
</tbody>
</table>
</li>

<li>
<p>
Step 4
</p>
<table>
<caption class="t-above">
<span class="table-number">Table 8:</span> Recursive Table</caption>

<colgroup>
<col class="org-left">

<col class="org-right">
</colgroup>
<tbody>
<tr>
<td class="org-left">Alice</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-left">Bob</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left">Cindy</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left">Dave</td>
<td class="org-right">2</td>
</tr>
</tbody>
</table>

<table>
<caption class="t-above">
<span class="table-number">Table 9:</span> Queue</caption>

<colgroup>
<col class="org-left">

<col class="org-right">
</colgroup>
<tbody>
<tr>
<td class="org-left">Emma</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-left">Fred</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-left">Gail</td>
<td class="org-right">2</td>
</tr>
</tbody>
</table>
</li>

<li>
<p>
Step 5
</p>
<table>
<caption class="t-above">
<span class="table-number">Table 10:</span> Recursive Table</caption>

<colgroup>
<col class="org-left">

<col class="org-right">
</colgroup>
<tbody>
<tr>
<td class="org-left">Alice</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-left">Bob</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left">Cindy</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left">Dave</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-left">Emma</td>
<td class="org-right">2</td>
</tr>
</tbody>
</table>

<table>
<caption class="t-above">
<span class="table-number">Table 11:</span> Queue</caption>

<colgroup>
<col class="org-left">

<col class="org-right">
</colgroup>
<tbody>
<tr>
<td class="org-left">Fred</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-left">Gail</td>
<td class="org-right">2</td>
</tr>
</tbody>
</table>
</li>

<li>
<p>
Step 6
</p>
<table>
<caption class="t-above">
<span class="table-number">Table 12:</span> Recursive Table</caption>

<colgroup>
<col class="org-left">

<col class="org-right">
</colgroup>
<tbody>
<tr>
<td class="org-left">Alice</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-left">Bob</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left">Cindy</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left">Dave</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-left">Emma</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-left">Fred</td>
<td class="org-right">2</td>
</tr>
</tbody>
</table>

<table>
<caption class="t-above">
<span class="table-number">Table 13:</span> Queue</caption>

<colgroup>
<col class="org-left">

<col class="org-right">
</colgroup>
<tbody>
<tr>
<td class="org-left">Gail</td>
<td class="org-right">2</td>
</tr>
</tbody>
</table>
</li>

<li>
<p>
Step 7
</p>
<table>
<caption class="t-above">
<span class="table-number">Table 14:</span> Recursive Table</caption>

<colgroup>
<col class="org-left">

<col class="org-right">
</colgroup>
<tbody>
<tr>
<td class="org-left">Alice</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-left">Bob</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left">Cindy</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left">Dave</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-left">Emma</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-left">Fred</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-left">Gail</td>
<td class="org-right">2</td>
</tr>
</tbody>
</table>

<p>
The queue is empty.
</p>
</li>
</ul>
</div>
</div>
<div id="outline-container-org62155e8" class="outline-4">
<h4 id="org62155e8">
<span class="section-number-4">1.1.2</span> Depth First Search</h4>
<div class="outline-text-4" id="text-1-1-2">
<p>
The SQLite article also gives an example of depth first search.
</p>
<div class="org-src-container">
<pre class="src src-sqlite"><span class="org-keyword">WITH</span> <span class="org-keyword">RECURSIVE</span>
  under_alice(<span class="org-keyword">name</span>,<span class="org-keyword">level</span>) <span class="org-keyword">AS</span> (
    <span class="org-keyword">VALUES</span>(<span class="org-string">'Alice'</span>,0)
    <span class="org-keyword">UNION</span> <span class="org-keyword">ALL</span>
    <span class="org-keyword">SELECT</span> org.<span class="org-keyword">name</span>, under_alice.<span class="org-keyword">level</span>+1
      <span class="org-keyword">FROM</span> org <span class="org-keyword">JOIN</span> under_alice <span class="org-keyword">ON</span> org.boss=under_alice.<span class="org-keyword">name</span>
     <span class="org-keyword">ORDER</span> <span class="org-keyword">BY</span> 2 <span class="org-keyword">DESC</span>
  )
<span class="org-keyword">SELECT</span> substr(<span class="org-string">'..........'</span>,1,<span class="org-keyword">level</span>*3) || <span class="org-keyword">name</span> <span class="org-keyword">FROM</span> under_alice;
</pre>
</div>

<p>
The <code>ORDER BY</code> number refers to the second column in the <code>SELECT</code> statement. The
<code>DESC</code> means that elements get taken from the bottom of the <em>queue</em> instead of
the top; that is, the queue acts as a stack.
</p>

<ul class="org-ul">
<li>
<p>
Step 0
</p>
<table>
<caption class="t-above">
<span class="table-number">Table 15:</span> Queue</caption>

<colgroup>
<col class="org-left">

<col class="org-right">
</colgroup>
<tbody>
<tr>
<td class="org-left">Alice</td>
<td class="org-right">0</td>
</tr>
</tbody>
</table>

<p>
The recursive table is empty.
</p>
</li>

<li>
<p>
Step 1
</p>
<table>
<caption class="t-above">
<span class="table-number">Table 16:</span> Recursive Table</caption>

<colgroup>
<col class="org-left">

<col class="org-right">
</colgroup>
<tbody>
<tr>
<td class="org-left">Alice</td>
<td class="org-right">0</td>
</tr>
</tbody>
</table>

<table>
<caption class="t-above">
<span class="table-number">Table 17:</span> Queue</caption>

<colgroup>
<col class="org-left">

<col class="org-right">
</colgroup>
<tbody>
<tr>
<td class="org-left">Bob</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left">Cindy</td>
<td class="org-right">1</td>
</tr>
</tbody>
</table>
</li>

<li>
<p>
Step 2
</p>
<table>
<caption class="t-above">
<span class="table-number">Table 18:</span> Recursive Table</caption>

<colgroup>
<col class="org-left">

<col class="org-right">
</colgroup>
<tbody>
<tr>
<td class="org-left">Alice</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-left">Cindy</td>
<td class="org-right">1</td>
</tr>
</tbody>
</table>

<table>
<caption class="t-above">
<span class="table-number">Table 19:</span> Queue</caption>

<colgroup>
<col class="org-left">

<col class="org-right">
</colgroup>
<tbody>
<tr>
<td class="org-left">Bob</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left">Fred</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-left">Gail</td>
<td class="org-right">2</td>
</tr>
</tbody>
</table>
</li>

<li>
<p>
Step 3
</p>
<table>
<caption class="t-above">
<span class="table-number">Table 20:</span> Recursive Table</caption>

<colgroup>
<col class="org-left">

<col class="org-right">
</colgroup>
<tbody>
<tr>
<td class="org-left">Alice</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-left">Cindy</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left">Gail</td>
<td class="org-right">2</td>
</tr>
</tbody>
</table>

<table>
<caption class="t-above">
<span class="table-number">Table 21:</span> Queue</caption>

<colgroup>
<col class="org-left">

<col class="org-right">
</colgroup>
<tbody>
<tr>
<td class="org-left">Bob</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left">Fred</td>
<td class="org-right">2</td>
</tr>
</tbody>
</table>
</li>

<li>
<p>
Step 4
</p>
<table>
<caption class="t-above">
<span class="table-number">Table 22:</span> Recursive Table</caption>

<colgroup>
<col class="org-left">

<col class="org-right">
</colgroup>
<tbody>
<tr>
<td class="org-left">Alice</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-left">Cindy</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left">Gail</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-left">Fred</td>
<td class="org-right">2</td>
</tr>
</tbody>
</table>

<table>
<caption class="t-above">
<span class="table-number">Table 23:</span> Queue</caption>

<colgroup>
<col class="org-left">

<col class="org-right">
</colgroup>
<tbody>
<tr>
<td class="org-left">Bob</td>
<td class="org-right">1</td>
</tr>
</tbody>
</table>
</li>

<li>
<p>
Step 5
</p>
<table>
<caption class="t-above">
<span class="table-number">Table 24:</span> Recursive Table</caption>

<colgroup>
<col class="org-left">

<col class="org-right">
</colgroup>
<tbody>
<tr>
<td class="org-left">Alice</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-left">Cindy</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left">Gail</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-left">Fred</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-left">Bob</td>
<td class="org-right">1</td>
</tr>
</tbody>
</table>

<table>
<caption class="t-above">
<span class="table-number">Table 25:</span> Queue</caption>

<colgroup>
<col class="org-left">

<col class="org-right">
</colgroup>
<tbody>
<tr>
<td class="org-left">Dave</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-left">Emma</td>
<td class="org-right">2</td>
</tr>
</tbody>
</table>
</li>

<li>
<p>
Step 6
</p>
<table>
<caption class="t-above">
<span class="table-number">Table 26:</span> Recursive Table</caption>

<colgroup>
<col class="org-left">

<col class="org-right">
</colgroup>
<tbody>
<tr>
<td class="org-left">Alice</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-left">Cindy</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left">Gail</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-left">Fred</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-left">Bob</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left">Emma</td>
<td class="org-right">2</td>
</tr>
</tbody>
</table>

<table>
<caption class="t-above">
<span class="table-number">Table 27:</span> Queue</caption>

<colgroup>
<col class="org-left">

<col class="org-right">
</colgroup>
<tbody>
<tr>
<td class="org-left">Dave</td>
<td class="org-right">2</td>
</tr>
</tbody>
</table>
</li>

<li>
<p>
Step 7
</p>
<table>
<caption class="t-above">
<span class="table-number">Table 28:</span> Recursive Table</caption>

<colgroup>
<col class="org-left">

<col class="org-right">
</colgroup>
<tbody>
<tr>
<td class="org-left">Alice</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-left">Cindy</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left">Gail</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-left">Fred</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-left">Bob</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left">Emma</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-left">Dave</td>
<td class="org-right">2</td>
</tr>
</tbody>
</table>

<p>
The queue is empty.
</p>
</li>
</ul>

<p>
In the previous examples, some of the row orderings were random.  For
example, in step 1, the row order of <code>(Bob,1; Cindy,1)</code> could have been
reversed; so if determinism matters, you could sub-sort the recursive query:
<code>ORDER BY 2 DESC, 1 DESC</code>.
</p>
</div>
</div>
</div>
<div id="outline-container-org99139fa" class="outline-3">
<h3 id="org99139fa">
<span class="section-number-3">1.2</span> Memoization Example</h3>
<div class="outline-text-3" id="text-1-2">
<p>
Here is a recursive CTE, adapted from <a href="https://www.codeproject.com/tips/811924/fibonacci-sequence-using-sql-server-cte">Code Project</a>, that computes the
Fibonacci sequence. 
</p>

<div class="org-src-container">
<pre class="src src-sqlite">.timer <span class="org-keyword">on</span>
<span class="org-keyword">WITH</span> <span class="org-keyword">RECURSIVE</span> nth_fibonacci(i, fiboNumber, nextNumber) <span class="org-keyword">AS</span> (
     <span class="org-keyword">SELECT</span> 0 <span class="org-keyword">AS</span> i, 0 <span class="org-keyword">AS</span> fiboNumber, 1 <span class="org-keyword">AS</span> nextNumber
     <span class="org-keyword">UNION</span> <span class="org-keyword">ALL</span>
     <span class="org-keyword">SELECT</span> a.i + 1 <span class="org-keyword">AS</span> i, a.nextNumber <span class="org-keyword">AS</span> fiboNumber, a.fiboNumber + a.nextNumber <span class="org-keyword">AS</span> nextNumber
     <span class="org-keyword">FROM</span> nth_Fibonacci <span class="org-keyword">AS</span> a
     <span class="org-keyword">LIMIT</span> 1478
)
<span class="org-keyword">SELECT</span> fiboNumber <span class="org-keyword">FROM</span> nth_fibonacci <span class="org-keyword">ORDER</span> <span class="org-keyword">BY</span> i <span class="org-keyword">DESC</span> <span class="org-keyword">LIMIT</span> 10;
</pre>
</div>

<table>
<caption class="t-above">
<span class="table-number">Table 29:</span> Last nine Fibonacci numbers expressible in double precision floats and run-time.</caption>

<colgroup>
<col class="org-right">
</colgroup>
<tbody>
<tr>
<td class="org-right">Inf</td>
</tr>

<tr>
<td class="org-right">1.3069892237634e+308</td>
</tr>

<tr>
<td class="org-right">8.07763763215622e+307</td>
</tr>

<tr>
<td class="org-right">4.99225460547777e+307</td>
</tr>

<tr>
<td class="org-right">3.08538302667846e+307</td>
</tr>

<tr>
<td class="org-right">1.90687157879931e+307</td>
</tr>

<tr>
<td class="org-right">1.17851144787915e+307</td>
</tr>

<tr>
<td class="org-right">7.28360130920163e+306</td>
</tr>

<tr>
<td class="org-right">4.50151316958984e+306</td>
</tr>

<tr>
<td class="org-right">2.78208813961179e+306</td>
</tr>

<tr>
<td class="org-right">Run Time: real 0.002 user 0.001000 sys 0.001000</td>
</tr>
</tbody>
</table>

<p>
While SQLite quickly computes all expressible Fibonacci values and is smart
enough to optimize away the recursion, the Fibonacci function is a popular
example to show memoization. Memoization is where intermediate results are
stored so that repeated calls do not have to recompute those values.  An
external tables can be used to memoize results.  Given the following table
and starting data:
</p>

<div class="org-src-container">
<pre class="src src-sqlite"><span class="org-keyword">CREATE</span> <span class="org-keyword">TABLE</span> <span class="org-function-name">Fibonacci</span> (
  i <span class="org-type">INTEGER</span> <span class="org-keyword">PRIMARY</span> <span class="org-keyword">KEY</span>,
  fibo <span class="org-type">INTEGER</span>
) <span class="org-keyword">WITHOUT</span> ROWID;
<span class="org-keyword">INSERT</span> <span class="org-keyword">INTO</span> fibonacci <span class="org-keyword">VALUES</span>(0,0);
<span class="org-keyword">INSERT</span> <span class="org-keyword">INTO</span> fibonacci <span class="org-keyword">VALUES</span>(1,1);
</pre>
</div>

<p>
The following code computes the next number in the sequence, stores it, and
returns the sequence. Repeated calls will add succeeding values to the table.
This query is a CTE but not a recursive one. Getting the N<sup>th</sup> term,
requires repeatedly calling this <code>WITH...INSERT</code> statement <code>N</code> times.  If you
add another <code>INSERT</code> statement after the first one, it will not see the <code>WITH</code>
statement; only the first <code>INSERT</code> knows about the <code>WITH</code> statement.
</p>
<div class="org-src-container">
<pre class="src src-sqlite"><span class="org-keyword">WITH</span> next_fibonacci(i, fibo) <span class="org-keyword">AS</span> (
<span class="org-comment">-- compute the next Fibonacci number in the sequence</span>
    <span class="org-keyword">SELECT</span> <span class="org-builtin">MAX</span>(i) + 1, <span class="org-builtin">SUM</span>(fibo)
    <span class="org-keyword">FROM</span> Fibonacci
    <span class="org-keyword">WHERE</span>
    <span class="org-comment">-- Get only the last two records</span>
    Fibonacci.i = (<span class="org-keyword">SELECT</span> <span class="org-builtin">MAX</span>(i) <span class="org-keyword">FROM</span> Fibonacci)
    <span class="org-keyword">OR</span> Fibonacci.i = (<span class="org-keyword">SELECT</span> <span class="org-builtin">MAX</span>(i) - 1 <span class="org-keyword">FROM</span> Fibonacci)
)

<span class="org-keyword">INSERT</span> <span class="org-keyword">INTO</span> Fibonacci
<span class="org-keyword">SELECT</span> i, fibo <span class="org-keyword">FROM</span> next_fibonacci;
<span class="org-keyword">SELECT</span> * <span class="org-keyword">FROM</span> Fibonacci;
</pre>
</div>

<p>
Combining the last two queries, the recursive CTE and the non-recursive CTE,
we get a recursive CTE that can compute the first <code>N</code> values; in this case,
up to the 60<sup>th</sup> value. Computing an arbitrary <code>N</code> would require an external
program to modify the query's <code>N</code> value. In this case, Emacs Org <a href="http://orgmode.org/worg/org-contrib/babel/">Babel</a> is
used to set it. Filtering the <code>nth_fibonacci</code> output is necessary because the
CTE will return the <code>N+1</code> Fibonacci value.
</p>

<div class="org-src-container">
<pre class="src src-sqlite"><span class="org-keyword">WITH</span> <span class="org-keyword">RECURSIVE</span> nth_fibonacci(i, prevNumber, fiboNumber) <span class="org-keyword">AS</span> (
     <span class="org-keyword">SELECT</span> <span class="org-builtin">MAX</span>(i) + 1 <span class="org-keyword">AS</span> i, <span class="org-builtin">MAX</span>(fibo) <span class="org-keyword">AS</span> prevNumber, <span class="org-builtin">SUM</span>(fibo) <span class="org-keyword">AS</span> fiboNumber
     <span class="org-keyword">FROM</span> Fibonacci
     <span class="org-keyword">WHERE</span> Fibonacci.i = (<span class="org-keyword">SELECT</span> <span class="org-builtin">MAX</span>(i) <span class="org-keyword">FROM</span> Fibonacci)
     <span class="org-keyword">OR</span> Fibonacci.i = (<span class="org-keyword">SELECT</span> <span class="org-builtin">MAX</span>(i) - 1 <span class="org-keyword">FROM</span> Fibonacci)

     <span class="org-keyword">UNION</span> <span class="org-keyword">ALL</span>

     <span class="org-keyword">SELECT</span> prev.i + 1 <span class="org-keyword">AS</span> i,
            prev.fiboNumber <span class="org-keyword">AS</span> prevNumber,
            prev.fiboNumber + prev.prevNumber <span class="org-keyword">AS</span> fiboNumber
     <span class="org-keyword">FROM</span> nth_Fibonacci <span class="org-keyword">AS</span> prev
     <span class="org-keyword">WHERE</span> prev.i &lt; $N
)
<span class="org-keyword">INSERT</span> <span class="org-keyword">INTO</span> fibonacci
<span class="org-keyword">SELECT</span> i, fiboNumber <span class="org-keyword">AS</span> fibo <span class="org-keyword">FROM</span> nth_Fibonacci <span class="org-keyword">WHERE</span> i &lt;= $N;

<span class="org-keyword">SELECT</span> i, fibo <span class="org-keyword">FROM</span> fibonacci <span class="org-keyword">WHERE</span> i = $N;
</pre>
</div>
</div>
</div>

<div id="outline-container-org6725559" class="outline-3">
<h3 id="org6725559">
<span class="section-number-3">1.3</span> Transitive Closure Example</h3>
<div class="outline-text-3" id="text-1-3">
<p>
Aho and Ullman give the example of finding whether one can take flights to
get from one airport to another. Direct and one-stop flights are possible to
find using relational algebra; however, more than one stop requires looping
or recursion on intermediate output until a steady state is reached.
</p>

<p>
Given the following table of flights, where <em>source</em> is the flight's starting
airport, <em>dest</em> is the destination airport, <em>departs</em> is the departure time,
and <em>arrives</em> is the arrival time, each flight record represents a node on a
graph.
</p>

<table id="org88de76f">
<caption class="t-above">
<span class="table-number">Table 30:</span> Flights.</caption>

<colgroup>
<col class="org-right">

<col class="org-left">

<col class="org-left">

<col class="org-right">

<col class="org-right">
</colgroup>
<tbody>
<tr>
<td class="org-right">id</td>
<td class="org-left">source</td>
<td class="org-left">dest</td>
<td class="org-right">departs</td>
<td class="org-right">arrives</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-left">A</td>
<td class="org-left">B</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-left">A</td>
<td class="org-left">B</td>
<td class="org-right">3</td>
<td class="org-right">4</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-left">B</td>
<td class="org-left">C</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-left">B</td>
<td class="org-left">C</td>
<td class="org-right">3</td>
<td class="org-right">4</td>
</tr>

<tr>
<td class="org-right">4</td>
<td class="org-left">C</td>
<td class="org-left">D</td>
<td class="org-right">4</td>
<td class="org-right">5</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-left">D</td>
<td class="org-left">E</td>
<td class="org-right">5</td>
<td class="org-right">6</td>
</tr>
</tbody>
</table>
<p>
We can get possible one-stop flights by joining the table with itself where
flights arrive at or before another flight at the same airport. To get
multi-stop flights, the <a href="https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm">Floyd-Warshall algorithm</a> is used.  The Floyd-Warshall
algorithm uses a Boolean connection table; true for connected, false for
unconnected, for each pair of nodes.  The example here, instead, uses a list
of connections.  A connections is added to the list if there are two
connections with a common node.  The algorithm uses a triple nested loop that
iterates through all possible node connections, including connections that
start and end at the same node. There are <img class="org-svg" src="ltximg/sql-transitive-closure_731951f1052361d2d6fe5b5440ea4660064bb31b.svg" alt="SVG Image."> number of possible
connections, <img class="org-svg" src="ltximg/sql-transitive-closure_1604386ea47346f67afa73a28e7f8ad277037010.svg" alt="SVG Image."> being the number of nodes.  After <img class="org-svg" src="ltximg/sql-transitive-closure_782a4cff3074d9e11460003c32baab46dde8f863.svg" alt="SVG Image."> iterations, any
further iterations will not affect the output. <img class="org-svg" src="ltximg/sql-transitive-closure_1604386ea47346f67afa73a28e7f8ad277037010.svg" alt="SVG Image."> times more iterations than
there are possible connections is necessary to check all connection pairs for
new connections after ones have been made in the previous iteration. It is
possible to short circuit the loop if two consecutive loops produce equal
output; and if there are no connections to begin with, the algorithm can be
avoided all together.
</p>


<div class="figure">
<p><img class="org-svg" src="sql-transitive-closure/flights.svg" alt="Flights directed graph.">
</p>
</div>

<p>
Black arrows in the diagram, represent one-stop connections; think of them as
running to the next gate. Red and blue arrows are found by the Floyd-Warshall
algorithm. The red arrows are computed during the first iteration by looking
for pairs of black arrows with common nodes.  These are two-stop flights.
The blue arrow is a three stop connection that is found after the red arrows
are established, where the algorithm looks for red and black arrow pairs with
common nodes.
</p>

<p>
However, knowing that you can get from one airport to another is not
necessarily good enough.  You would want to have your flight itinerary.  All
itineraries can be computed by slightly modifying the Floyd-Warshall
algorithm.
</p>
</div>

<div id="outline-container-orge7328d7" class="outline-4">
<h4 id="orge7328d7">
<span class="section-number-4">1.3.1</span> Using Relational Algebra and Python</h4>
<div class="outline-text-4" id="text-1-3-1">
<p>
The following Python code uses relational.py and Emacs Org mode.  See my
previous post in the thread for more on that.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">import</span> sys
sys.path.append(<span class="org-string">"/home/devin/projects/relational/"</span>)
<span class="org-keyword">from</span> relational.relation_org <span class="org-keyword">import</span> RelationOrg
<span class="org-variable-name">flights</span> = RelationOrg(flights)
<span class="org-variable-name">flight_ids</span> = flights.projection(<span class="org-string">"id"</span>)
<span class="org-comment-delimiter"># </span><span class="org-comment">use Warshall's algorithm to compute indirect connections</span>
<span class="org-variable-name">flight_num</span> = <span class="org-builtin">len</span>(flights)

<span class="org-comment-delimiter"># </span><span class="org-comment">add one-stop connections to the connections table</span>
<span class="org-variable-name">connections</span> = flights.thetajoin(flights.rename({<span class="org-string">"id"</span>:<span class="org-string">"dest_id"</span>,
                                                <span class="org-string">"source"</span>:<span class="org-string">"source_d"</span>,
                                                <span class="org-string">"dest"</span>:<span class="org-string">"dest_d"</span>,
                                                <span class="org-string">"departs"</span>:<span class="org-string">"departs_d"</span>,
                                                <span class="org-string">"arrives"</span>:<span class="org-string">"arrives_d"</span>}),
                                <span class="org-string">"dest == source_d and arrives &lt;= departs_d"</span>)\
                     .projection(<span class="org-string">"id"</span>, <span class="org-string">"dest_id"</span>).rename({<span class="org-string">"id"</span>:<span class="org-string">"source_id"</span>})
<span class="org-variable-name">connections_org</span> = connections.rename({<span class="org-string">"source_id"</span>: <span class="org-string">"source_id_c"</span>,
                                      <span class="org-string">"dest_id"</span>: <span class="org-string">"dest_id_c"</span>})

<span class="org-comment-delimiter"># </span><span class="org-comment">store intermediate results, currently only have one-stop flight itineraries</span>
<span class="org-variable-name">itineraries</span> = connections.thetajoin(connections.projection(<span class="org-string">"source_id"</span>)\
                                    .rename({<span class="org-string">"source_id"</span>:<span class="org-string">"connection_id"</span>}),
                                    <span class="org-string">"source_id == connection_id"</span>)
<span class="org-variable-name">itineraries_org</span> = itineraries.rename({<span class="org-string">"connection_id"</span>:<span class="org-string">"connection_id_n"</span>,
                                      <span class="org-string">"source_id"</span>:<span class="org-string">"source_id_n"</span>,
                                      <span class="org-string">"dest_id"</span>:<span class="org-string">"dest_id_n"</span>})

<span class="org-keyword">if</span> <span class="org-builtin">len</span>(connections) &gt; 0:
    <span class="org-variable-name">i</span> = 0
    <span class="org-keyword">while</span> i &lt; flight_num:
        <span class="org-comment-delimiter"># </span><span class="org-comment">find secondary connections and remove known connections from</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">new_connections list so as to not insert existing connections,</span>
        <span class="org-variable-name">connections</span> = connections.thetajoin(connections_org,
                                            <span class="org-string">"dest_id == source_id_c"</span>)\
                                 .projection(<span class="org-string">"source_id"</span>, <span class="org-string">"dest_id_c"</span>)\
                                 .rename({<span class="org-string">"dest_id_c"</span>:<span class="org-string">"dest_id"</span>})\
                                 .union(connections)

        <span class="org-comment-delimiter"># </span><span class="org-comment">add connections to the itineraries table</span>
        <span class="org-variable-name">itineraries</span> = itineraries.thetajoin(itineraries_org,\
                                            <span class="org-string">"dest_id == source_id_n"</span>)\
                                 .projection(<span class="org-string">"dest_id"</span>, <span class="org-string">"dest_id_n"</span>, <span class="org-string">"connection_id"</span>)\
                                 .rename({<span class="org-string">"dest_id"</span>: <span class="org-string">"source_id"</span>, <span class="org-string">"dest_id_n"</span>:<span class="org-string">"dest_id"</span>})\
                                 .union(itineraries)
        <span class="org-variable-name">i</span> += 1

<span class="org-variable-name">result</span> = flights.product(flights.rename({<span class="org-string">"id"</span>:<span class="org-string">"dest_id"</span>,
                                         <span class="org-string">"source"</span>:<span class="org-string">"source_d"</span>,
                                         <span class="org-string">"dest"</span>:<span class="org-string">"dest_d"</span>,
                                         <span class="org-string">"departs"</span>:<span class="org-string">"departs_d"</span>,
                                         <span class="org-string">"arrives"</span>:<span class="org-string">"arrives_d"</span>}))\
         .rename({<span class="org-string">"id"</span>:<span class="org-string">"source_id"</span>})\
         .semijoin_left(connections)\
         .projection(<span class="org-string">"source_id"</span>, <span class="org-string">"dest_id"</span>, <span class="org-string">"source"</span>, <span class="org-string">"dest_d"</span>, <span class="org-string">"departs"</span>, <span class="org-string">"arrives_d"</span>)
<span class="org-comment-delimiter">#</span><span class="org-comment">return str(RelationOrg(connections))</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">return str(RelationOrg(itineraries))</span>
<span class="org-keyword">return</span> <span class="org-builtin">str</span>(RelationOrg(result))
</pre>
</div>

<p>
<code>flights</code> refers to the before mentioned flights table. Initially, the
<code>connections</code> variable is a two-column, many-to-many relation table
describing possible one-stop connections between <code>source_id</code> and
<code>dest_id</code>. The <code>itineraries</code> variable adds an extra column, <code>connection_id</code>,
to the <code>connections</code> table, that being the starting connection ID. The code
only needs to iterate <code>N</code> times because the two inner loops are accomplished
by the <code>thetajoin</code>. Renaming is necessary because <code>thetajoin</code> does not allow
for duplicate column names. Intermediate results are aggregated into the
<code>connections</code> and <code>itineraries</code> variables by UNION-ing the known connections
with the new found connections. The only difference between <code>connections</code>
and <code>itineraries</code> is that the <code>source_id</code> is projected in the former, while
the <code>dest_id</code> is projected in the later. The <code>result</code> variable shows the
flight information associated with the entries in the connections table. It
is created by computing all possible connections between nodes and keeping
only those connections that exist in the connections table, joining on
<code>dest_id</code> and <code>source_id</code>.
</p>

<table>
<caption class="t-above">
<span class="table-number">Table 31:</span> <code>connections</code> table is the graph's transitive closure.</caption>

<colgroup>
<col class="org-right">

<col class="org-right">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right"><code>source_id</code></th>
<th scope="col" class="org-right"><code>dest_id</code></th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-right">3</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">4</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">5</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-right">4</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-right">5</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-right">4</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-right">5</td>
</tr>

<tr>
<td class="org-right">4</td>
<td class="org-right">5</td>
</tr>
</tbody>
</table>

<table>
<caption class="t-above">
<span class="table-number">Table 32:</span> <code>itineraries</code> table shows all four possible flight itineraries whose destination is airport E. <code>connection_id</code> is the starting connection.</caption>

<colgroup>
<col class="org-right">

<col class="org-right">

<col class="org-right">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right"><code>connection_id</code></th>
<th scope="col" class="org-right"><code>source_id</code></th>
<th scope="col" class="org-right"><code>dest_id</code></th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">3</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">3</td>
<td class="org-right">4</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">4</td>
<td class="org-right">5</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-right">2</td>
<td class="org-right">2</td>
<td class="org-right">4</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-right">4</td>
<td class="org-right">5</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-right">3</td>
<td class="org-right">3</td>
<td class="org-right">4</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-right">4</td>
<td class="org-right">5</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-right">4</td>
<td class="org-right">4</td>
<td class="org-right">5</td>
</tr>
</tbody>
</table>

<table>
<caption class="t-above">
<span class="table-number">Table 33:</span> This is the <code>result</code> table. It is <code>connections</code> table with the last four columns in the <code>flights</code> table joined to it. <code>source_id</code> is the first flight number. <code>dest_id</code> is the last flight number. <code>source</code> is the first flight's departure location. <code>dest_d</code> is the last flight's arrival location. <code>departs</code> is the first flight's departure time. <code>arrives_d</code> is the last flight's arrival time.</caption>

<colgroup>
<col class="org-right">

<col class="org-right">

<col class="org-left">

<col class="org-left">

<col class="org-right">

<col class="org-right">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right"><code>source_id</code></th>
<th scope="col" class="org-right"><code>dest_id</code></th>
<th scope="col" class="org-left"><code>source</code></th>
<th scope="col" class="org-left"><code>dest_d</code></th>
<th scope="col" class="org-right"><code>departs</code></th>
<th scope="col" class="org-right"><code>arrives_d</code></th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-right">3</td>
<td class="org-left">A</td>
<td class="org-left">C</td>
<td class="org-right">0</td>
<td class="org-right">4</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">4</td>
<td class="org-left">A</td>
<td class="org-left">D</td>
<td class="org-right">0</td>
<td class="org-right">5</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">5</td>
<td class="org-left">A</td>
<td class="org-left">E</td>
<td class="org-right">0</td>
<td class="org-right">6</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-right">4</td>
<td class="org-left">B</td>
<td class="org-left">D</td>
<td class="org-right">0</td>
<td class="org-right">5</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-right">5</td>
<td class="org-left">B</td>
<td class="org-left">E</td>
<td class="org-right">0</td>
<td class="org-right">6</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-right">4</td>
<td class="org-left">B</td>
<td class="org-left">D</td>
<td class="org-right">3</td>
<td class="org-right">5</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-right">5</td>
<td class="org-left">B</td>
<td class="org-left">E</td>
<td class="org-right">3</td>
<td class="org-right">6</td>
</tr>

<tr>
<td class="org-right">4</td>
<td class="org-right">5</td>
<td class="org-left">C</td>
<td class="org-left">E</td>
<td class="org-right">4</td>
<td class="org-right">6</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org991be95" class="outline-4">
<h4 id="org991be95">
<span class="section-number-4">1.3.2</span> Using SQLite and Recursive Common Table Expressions</h4>
<div class="outline-text-4" id="text-1-3-2">
<p>
Given example table
</p>
<div class="org-src-container">
<pre class="src src-sqlite"><span class="org-keyword">CREATE</span> <span class="org-keyword">TABLE</span> <span class="org-function-name">Flights</span> (
       id <span class="org-keyword">NUMBER</span>,
       <span class="org-keyword">source</span> TEXT(2),
       dest TEXT(2),
       departs <span class="org-keyword">NUMBER</span>,
       arrives <span class="org-keyword">NUMBER</span>,
       <span class="org-keyword">CONSTRAINT</span> FlightsPK <span class="org-keyword">PRIMARY</span> <span class="org-keyword">KEY</span> (id)
);
<span class="org-keyword">INSERT</span> <span class="org-keyword">INTO</span> Flights(id, <span class="org-keyword">source</span>, dest, departs, arrives) <span class="org-keyword">VALUES</span> (0, <span class="org-string">'A'</span>, <span class="org-string">'B'</span>, 0, 1);
<span class="org-keyword">INSERT</span> <span class="org-keyword">INTO</span> Flights(id, <span class="org-keyword">source</span>, dest, departs, arrives) <span class="org-keyword">VALUES</span> (1, <span class="org-string">'A'</span>, <span class="org-string">'B'</span>, 3, 4);
<span class="org-keyword">INSERT</span> <span class="org-keyword">INTO</span> Flights(id, <span class="org-keyword">source</span>, dest, departs, arrives) <span class="org-keyword">VALUES</span> (2, <span class="org-string">'B'</span>, <span class="org-string">'C'</span>, 0, 1);
<span class="org-keyword">INSERT</span> <span class="org-keyword">INTO</span> Flights(id, <span class="org-keyword">source</span>, dest, departs, arrives) <span class="org-keyword">VALUES</span> (3, <span class="org-string">'B'</span>, <span class="org-string">'C'</span>, 3, 4);
<span class="org-keyword">INSERT</span> <span class="org-keyword">INTO</span> Flights(id, <span class="org-keyword">source</span>, dest, departs, arrives) <span class="org-keyword">VALUES</span> (4, <span class="org-string">'C'</span>, <span class="org-string">'D'</span>, 4, 5);
<span class="org-keyword">INSERT</span> <span class="org-keyword">INTO</span> Flights(id, <span class="org-keyword">source</span>, dest, departs, arrives) <span class="org-keyword">VALUES</span> (5, <span class="org-string">'D'</span>, <span class="org-string">'E'</span>, 5, 6);
</pre>
</div>

<p>
the transitive closure and itineraries can be generated by using recursive
CTEs. The following code returns the transitive closure.
</p>

<div class="org-src-container">
<pre class="src src-sqlite"><span class="org-keyword">WITH</span> <span class="org-keyword">RECURSIVE</span>
connections(source_id, dest_id) <span class="org-keyword">AS</span> (
                   <span class="org-keyword">SELECT</span> <span class="org-keyword">DISTINCT</span> S.id, D.id
                   <span class="org-keyword">FROM</span> flights <span class="org-keyword">AS</span> S <span class="org-keyword">JOIN</span> flights <span class="org-keyword">AS</span> D
                   <span class="org-keyword">ON</span> S.dest = D.<span class="org-keyword">source</span> <span class="org-keyword">AND</span> S.arrives &lt;= D.departs
),

iterations(x) <span class="org-keyword">AS</span> (
              <span class="org-keyword">SELECT</span> <span class="org-builtin">COUNT</span>(*) <span class="org-keyword">FROM</span> Flights
),

trans_closure(source_id, dest_id) <span class="org-keyword">AS</span> (
                   <span class="org-keyword">SELECT</span> source_id, dest_id <span class="org-keyword">FROM</span> connections
                   <span class="org-keyword">UNION</span> <span class="org-keyword">ALL</span>
                   <span class="org-keyword">SELECT</span> A.source_id, B.dest_id
                   <span class="org-keyword">FROM</span> trans_closure <span class="org-keyword">AS</span> A <span class="org-keyword">JOIN</span> connections <span class="org-keyword">AS</span> B
                   <span class="org-keyword">ON</span> A.dest_id = B.source_id
                   <span class="org-keyword">LIMIT</span> (<span class="org-keyword">SELECT</span> (<span class="org-keyword">SELECT</span> x <span class="org-keyword">FROM</span> iterations) * (<span class="org-keyword">SELECT</span> x <span class="org-keyword">FROM</span> iterations))
)
<span class="org-keyword">SELECT</span> source_id, dest_id <span class="org-keyword">FROM</span> trans_closure <span class="org-keyword">ORDER</span> <span class="org-keyword">BY</span> 1,2;
</pre>
</div>

<p>
The <code>connections</code> function is just a regular CTE that results in a table of
one-stop connections. <code>iterations</code> caches the <code>Flight</code> table length. The
<code>trans_closure</code> CTE is recursive. The <code>SELECT</code> statement before the <code>UNION ALL</code>
creates a table that the recursive operation, the code after the <code>UNION ALL</code>,
iterates through. The table <code>connections</code> has the value
</p>

<table>
<caption class="t-above">
<span class="table-number">Table 34:</span> <code>connections</code> table</caption>

<colgroup>
<col class="org-right">

<col class="org-right">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right"><code>source_id</code></th>
<th scope="col" class="org-right"><code>dest_id</code></th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-right">3</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-right">4</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-right">4</td>
</tr>

<tr>
<td class="org-right">4</td>
<td class="org-right">5</td>
</tr>
</tbody>
</table>
<p>
The table is copied into a <code>queue</code>. One of the rows is extracted from the <code>queue</code>
and inserted into <code>trans_closure</code>'s table. The <code>trans_closure</code> table is joined
with the <code>connections</code> table <code>ON A.dest_id = B.source_id</code> and the result is added
to the <code>queue</code>. The number of recursions is limited to the square of the <code>Flights</code>
table length. The <code>LIMIT</code> is not strictly needed in this example because the
<code>Flights</code> table is not circular.
</p>

<p>
A list of all itineraries can be produced by:
</p>
<div class="org-src-container">
<pre class="src src-sqlite"><span class="org-keyword">WITH</span> <span class="org-keyword">RECURSIVE</span>
itineraries(id, source_id, connection_id) <span class="org-keyword">AS</span>
(
        <span class="org-keyword">SELECT</span> <span class="org-keyword">DISTINCT</span> S.id, S.id, D.id
        <span class="org-keyword">FROM</span> flights <span class="org-keyword">AS</span> S <span class="org-keyword">JOIN</span> flights <span class="org-keyword">AS</span> D
        <span class="org-keyword">ON</span> S.dest = D.<span class="org-keyword">source</span> <span class="org-keyword">AND</span> S.arrives &lt;= D.departs
),

sub_graphs(id, source_id, connection_id) <span class="org-keyword">AS</span>
(
        <span class="org-keyword">SELECT</span> id, source_id, connection_id <span class="org-keyword">FROM</span> itineraries
        <span class="org-keyword">UNION</span> <span class="org-keyword">ALL</span>
        <span class="org-keyword">SELECT</span> A.id, A.connection_id, B.connection_id
        <span class="org-keyword">FROM</span> sub_graphs <span class="org-keyword">AS</span> A <span class="org-keyword">JOIN</span> itineraries <span class="org-keyword">AS</span> B
        <span class="org-keyword">ON</span> A.connection_id = B.source_id
)
<span class="org-keyword">SELECT</span> <span class="org-keyword">DISTINCT</span> id, source_id, connection_id <span class="org-keyword">FROM</span> sub_graphs <span class="org-keyword">ORDER</span> <span class="org-keyword">BY</span> 1,2,3;
</pre>
</div>

<p>
There are only minor differences between this code and the transitive
closure query.  <code>itineraries</code> is like <code>connections</code> in the previous example,
except the first node is used to group itinerary parts together.  In the
recursive query, the <code>JOIN ON</code> is the same, <code>dest_id</code> is renamed <code>connection_id</code>
(This was done to be consistent with the relational algebra example, and it
was done there to avoid naming collisions.), and the fields returned is
changed.
</p>
</div>
</div>

<div id="outline-container-org26850e3" class="outline-4">
<h4 id="org26850e3">
<span class="section-number-4">1.3.3</span> Cyclic Graphs</h4>
<div class="outline-text-4" id="text-1-3-3">
<p>
If the Flights table were cyclic, the recursive queries would require a
limit or an iterator. Unlike the relational algebra example, where the
entire intermediate result was joined with the entire original table, this
query is joining one of the intermediate results with the original table, so
<img class="org-svg" src="ltximg/sql-transitive-closure_731951f1052361d2d6fe5b5440ea4660064bb31b.svg" alt="SVG Image."> loops are needed. The iterative version has the advantage of being
order-able.  The <code>ORDER BY</code> clause requires a numeric field to sort on. This
controls whether the <code>queue</code> virtual table is treated as a stack or a queue.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 1: </span>Iterative version of the transitive closure.</label><pre class="src src-sqlite"><span class="org-keyword">WITH</span> <span class="org-keyword">RECURSIVE</span>
connections(source_id, dest_id) <span class="org-keyword">AS</span> (
     <span class="org-keyword">SELECT</span> <span class="org-keyword">DISTINCT</span> S.id, D.id
     <span class="org-keyword">FROM</span> flights <span class="org-keyword">AS</span> S <span class="org-keyword">JOIN</span> flights <span class="org-keyword">AS</span> D
     <span class="org-keyword">ON</span> S.dest = D.<span class="org-keyword">source</span> <span class="org-keyword">AND</span> S.arrives &lt;= D.departs
),

iterations(x) <span class="org-keyword">AS</span> (
<span class="org-keyword">SELECT</span> <span class="org-builtin">COUNT</span>(*) <span class="org-keyword">FROM</span> Flights
),

trans_closure(itter, source_id, dest_id) <span class="org-keyword">AS</span> (
     <span class="org-keyword">SELECT</span> 0, source_id, dest_id <span class="org-keyword">FROM</span> connections
     <span class="org-keyword">UNION</span> <span class="org-keyword">ALL</span>
     <span class="org-keyword">SELECT</span> itter + 1, A.source_id, B.dest_id
     <span class="org-keyword">FROM</span> trans_closure <span class="org-keyword">AS</span> A <span class="org-keyword">JOIN</span> connections <span class="org-keyword">AS</span> B
     <span class="org-keyword">ON</span> A.dest_id = B.source_id
     <span class="org-keyword">WHERE</span> itter &lt; (<span class="org-keyword">SELECT</span> (<span class="org-keyword">SELECT</span> x <span class="org-keyword">FROM</span> iterations) * (<span class="org-keyword">SELECT</span> x <span class="org-keyword">FROM</span> iterations))
     <span class="org-keyword">ORDER</span> <span class="org-keyword">BY</span> 1 <span class="org-keyword">ASC</span>
)
<span class="org-keyword">SELECT</span> <span class="org-keyword">DISTINCT</span> source_id, dest_id <span class="org-keyword">FROM</span> trans_closure <span class="org-keyword">ORDER</span> <span class="org-keyword">BY</span> 1,2;
</pre>
</div>
</div>

<div id="outline-container-org50fb68e" class="outline-5">
<h5 id="org50fb68e">
<span class="section-number-5">1.3.3.1</span> Another Example</h5>
<div class="outline-text-5" id="text-1-3-3-1">
<p>
Given a circular graph such as:
</p>
<div class="org-src-container">
<pre class="src src-sqlite"><span class="org-keyword">CREATE</span> <span class="org-keyword">TABLE</span> <span class="org-function-name">Circular</span> (
       <span class="org-keyword">source</span> TEXT(1),
       dest TEXT(1),
       <span class="org-keyword">CONSTRAINT</span> CircularPK <span class="org-keyword">PRIMARY</span> <span class="org-keyword">KEY</span> (<span class="org-keyword">source</span>, dest)
);
<span class="org-keyword">INSERT</span> <span class="org-keyword">INTO</span> Circular(<span class="org-keyword">source</span>, dest) <span class="org-keyword">VALUES</span> (<span class="org-string">'A'</span>, <span class="org-string">'B'</span>);
<span class="org-keyword">INSERT</span> <span class="org-keyword">INTO</span> Circular(<span class="org-keyword">source</span>, dest) <span class="org-keyword">VALUES</span> (<span class="org-string">'B'</span>, <span class="org-string">'C'</span>);
<span class="org-keyword">INSERT</span> <span class="org-keyword">INTO</span> Circular(<span class="org-keyword">source</span>, dest) <span class="org-keyword">VALUES</span> (<span class="org-string">'C'</span>, <span class="org-string">'A'</span>);
</pre>
</div>

<p>
Order might be necessary for transitive closure of cyclic graphs to ensure
FIFO execution.  Otherwise an undiscovered connection might get left at the
queue's top, while loops get repeatedly stored at the bottom and popped
off. Currently, FIFO is the default if <code>ORDER BY</code> is not used, but that is
not guaranteed.
</p>

<blockquote>
<p>
If there is no ORDER BY clause, then the order in which rows are extracted
is undefined. (In the current implementation, the queue becomes a FIFO if
the ORDER BY clause is omitted, but applications should not depend on that
fact since it might change.)
</p>
</blockquote>

<div class="org-src-container">
<pre class="src src-sqlite"><span class="org-keyword">WITH</span> <span class="org-keyword">RECURSIVE</span>
iterations(x) <span class="org-keyword">AS</span> (
<span class="org-keyword">SELECT</span> <span class="org-builtin">COUNT</span>(*) <span class="org-keyword">FROM</span> Circular
),

trans_closure(itter, <span class="org-keyword">source</span>, dest) <span class="org-keyword">AS</span> (
     <span class="org-keyword">SELECT</span> 0, <span class="org-keyword">source</span>, dest <span class="org-keyword">FROM</span> Circular
     <span class="org-keyword">UNION</span> <span class="org-keyword">ALL</span>
     <span class="org-keyword">SELECT</span> itter + 1, A.<span class="org-keyword">source</span>, B.dest
     <span class="org-keyword">FROM</span> trans_closure <span class="org-keyword">AS</span> A <span class="org-keyword">JOIN</span> Circular <span class="org-keyword">AS</span> B
     <span class="org-keyword">ON</span> A.dest = B.<span class="org-keyword">source</span>
     <span class="org-keyword">WHERE</span> itter &lt; (<span class="org-keyword">SELECT</span> (<span class="org-keyword">SELECT</span> x <span class="org-keyword">FROM</span> iterations) * (<span class="org-keyword">SELECT</span> x <span class="org-keyword">FROM</span> iterations))
     <span class="org-keyword">ORDER</span> <span class="org-keyword">BY</span> 1 <span class="org-keyword">ASC</span>
)
<span class="org-keyword">SELECT</span> <span class="org-keyword">DISTINCT</span> <span class="org-keyword">source</span>, dest <span class="org-keyword">FROM</span> trans_closure <span class="org-keyword">ORDER</span> <span class="org-keyword">BY</span> 1,2;
</pre>
</div>
</div>
</div>
</div>
</div>
</article>
</main><footer><div id="to-top-alt" class="mobile nav menu-btn"><a href="#" tabindex="-1">Back to Top</a></div></footer>
</body>
</html>
